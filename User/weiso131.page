---
title: weiso131 (許育瑋)
categories: Usesr
---
# 簡介
- 國立成功大學 資訊工程學系 116 級
- Github: [`weiso131`](https://github.com/weiso131)
- HackMD: [`weiso131`](https://hackmd.io/@weiso131)

# 2025 Linux 核心設計 春季班 自我評量
## 成果發表與貢獻
5 分。

- Concurrency Primer
  - 2025/6/11 [Note -latomic needed when using -mcx16](https://github.com/sysprog21/concurrency-primer/commit/f35f10856741fd0d3168a970cbee91542385145f)
  - 2025/6/11 [Fix function name in book: thread_pool_destroy](https://github.com/sysprog21/concurrency-primer/commit/1a4d1f78c69855cdb622edebe1f180f55069c918)
- 對課程使用的專案貢獻
  - ksort
    - 2025/3/23 [Fix uninitialized variable in error path](https://github.com/sysprog21/ksort/pull/6)
- 課程教材
  - 並行程式設計: Atomics 操作
     - 2025/5/8 `arm64` 得機器 → `arm64` 的機器
     - 2025/5/8 進進行 → 進行

## 作業/隨堂測驗
9 分。
- [2025q1 Homework1 (lab0)](https://hackmd.io/@weiso131/linux2025-homework1)
- [2025q1 Homework1 (ideas)](https://hackmd.io/@weiso131/linux2025-ideas)
- [2025q1 Homework2 (quiz1+2)](https://hackmd.io/@weiso131/linux2025-homework2)
- [2025q1 Homework3 (kxo)](https://hackmd.io/@weiso131/linux2025-homework3)
- [2025q1 Homework4 (quiz3+4)](https://hackmd.io/@weiso131/linux2025-homework4)
- [2025q1 Homework5 (assessment)](https://hackmd.io/@weiso131/linux2025-homework5)

作業重點回顧:
- lab0
  - 理解 list_sort 程式實作
    - 利用 perf 比較與自身實作的效能差異
    - 理解 final_merge 會更快的原因為: 藉由減少節點存取來減少 cache miss
    - 有趣的收穫 : 在 list_sort.c 發現 likely 可以控制分支預測，在計算機組織學到 control hazard 後理解其意義
  - 參考 list_sort 最後再把鍊結串列恢復成雙向的方法，將原本的 q_merge 做改進，使其能夠支援任意長度佇列的合併
- hw2
  - [實作自己的 memory allocator](https://github.com/weiso131/Customize_allocator)
  - [理解整數開根號的實作原理](https://hackmd.io/p6i9MFQ3RiW3PxDsagfAWw#sqrti) 
- hw3 的 kxo 
  - 實現 ctrl + Q 顯示對亦歷史紀錄
    - 利用鍊結串列儲存對亦資料
    - 自訂 ioctl ，確保多個 terminal 都能正確的取得對亦紀錄

## 期末專題
9 分。
[Linux 核心專題: 改進 kxo](https://hackmd.io/XWDjMx0bTmmNIWvlNHsvKw?both)

專題實現項目:
- 允許核心模組切換多種演算法，並整合 ttt 的 reinforcement_learning
  - 利用過去學過的 Q learning 演算法相關知識，更快的理解 TD learning 的實作，並將 reinforcement_learning 整合到此專案
- 縮減使用者和核心空間通訊的成本
  - 探討各種可能實作所需傳遞的 bytes 數量大小，並討論壓縮空間所需要的額外維護工作是否值得
- 改進棋盤展現的方式，並修訂核心通訊介面
  - 實現 write 支援使用者端棋盤控制
  - 實現 get_user_id 這個 ioctl 來在核心模組建立新的使用者並取得它在對應 tid 下的 user_id，此外，可藉由 bit_mask 指定使用的模式，實現使用者端切換 AI 演算法
- 支援多使用者並強化安全機制
  - 利用 current 這個 task_struct ，得知正在互動的執行緒的 id ，使其確保不同執行緒不會互相干擾
  - 了解 workqueue, kfifo, tasklet, wait_queue 的機制與使用要求，將這些知識應用於多使用者相關資料結構、流程的設計
- 理解何謂 lock-free
  - 釐清 lock-free 與 lock-less 的差異
  - 探討多使用者目前實作是否有可能在調整資料結構的使用後，達到 lock-free
- 在不犧牲棋力的前提，降低 CPU 使用率
  - 利用對 workqueue 的理解，使用 WQ_CPU_INTENSIVE 這個 flag ，確保 worker_pool 的其他工作不會被阻擋

觀摩其他同學的專題:
- [Linux 核心專題: 輕量級容器實作和擴充](https://hackmd.io/elX0ZH57S6CQIEdmsfGPBQ?view)
- [Linux 核心專題: 雲端檔案系統設計和實作](https://hackmd.io/G-5gwxcGSuKYBOt5tiomJQ?view)
- [Linux 核心專題: 重作 kxo (執行人: HeLunWu0317)](https://hackmd.io/@sysprog/r1hGKNN4lx)
- [Linux 核心專題: 重作 kxo (執行人: thwuedwin)](https://hackmd.io/@sysprog/Sk-tf74Ell)
- [Linux 核心專題: bitops 相關測驗題](https://hackmd.io/@sysprog/B13UVSQWel)

## 與授課教師的互動
9 分。
課堂問答:
- [2025-04-29 問答簡記](https://hackmd.io/Tcy6NPtnQiubDGyrRUnSdw#weiso131)
  - 討論 kxo
    - 課堂中發現 commit message 沒有提及如何重現，事後發現其實有寫在 commit message 中，只是 a keyboard event 似乎沒有 Ctrl + P 來的明確，之後使用 git rebase 修改 commit message
    - 探討如何讓一般使用者有權限執行 xo-user ，在專題藉由將 devnode 的 mode 設定為 0666 ，並移除對 sysfs 的依賴，實現了全域可讀可寫
    - 探討如何支援多使用者，在課堂簡記中提出簡單的想法，最後在專題中實現它
- [2025-06-10/17/24 問答簡記](https://hackmd.io/4UVPLWFgQ92AlG3N76dFKA#weiso131)
  探討如何利用 CAS 與 futex 機制實現簡單的 mutex_lock ，在課後實現了可行的 mutex_lock

一對一討論:
- 5/7
  考量我對核心模組的興趣，加上 [2025-04-29 問答簡記](https://hackmd.io/Tcy6NPtnQiubDGyrRUnSdw#weiso131) 對 kxo 支援多使用者的想法，老師將我的專題安排為改進 kxo ，並要求我把可能的改進項目列出來。

## 所見所聞所感
9分。
- 大二來修課，缺乏作業系統與計算機組織知識
  - 閱讀《Demystifying the Linux CPU Scheduler》補充作業系統的背景知識。 
  - 搭配教材內容，能與計算機組織剛學的內容相互印證，例如 memory barrier 負責處理指令重排的問題，當初還不能理解，學過 hazard 後才了解這是為了避免資料冒險而做的設計。
- Concurrency Primer
  - 理解 lock-free 的概念與其背後的意義。
  - 學會 atomic 的性質與運用 RMW（read-modify-write）操作的方式。
- 理解為什麼不要急著編譯執行
  在實作 kxo 的過程中深刻體會，沒有思考清楚就執行可能直接導致系統 crash，因此要盡可能在執行前確保程式正確性。
- 理解為什麼不能憑感覺寫程式
  起初我以為 workqueue 是 FIFO 結構，但查閱文件後才發現有其複雜的執行策略。若只靠印象實作，可能導致難以預期的錯誤。

閱讀《因為自動飲料機而延畢的那一年》之後，讓我更加慶幸自己當初選擇了資訊工程系。撰寫程式最大的優勢之一，就是可以迅速獲得回饋，立刻發現錯誤並加以修正。相比之下，處理硬體問題往往需要漫長的等待才能看到結果，調整流程也更加費時。然而，現實世界中的應用往往不僅限於純軟體開發，而是與各種領域密切結合。有些領域本身就具有長回饋週期，這是無法避免的。除了持續鞏固自己的專業能力，更要培養與其他領域專家有效溝通與合作的能力，這對於實際解決跨領域問題至關重要。

我曾經在大一下學期嘗試投入機器學習，花很多時間學各種工具和套件，雖然能跑出結果，卻對底層原理始終不夠理解。真正遇到問題時，不知道怎麼調整參數，也不了解資料的特性。後來我發現，單純使用現成工具其實很難累積真正的知識，尤其每個資料集背後都牽涉不同的領域背景，這讓我對自己是否該繼續往這條路上走產生了疑問。

相比之下，這門課從系統的角度重新打開了我的視野，讓我重新感受到電腦科學的深度與一致性。課程從 C 語言那些在大學中容易被忽略的細節開始教起，老師強調「不要憑感覺寫程式」，要求我們不確定的地方一定要查規格書、讀第一手文件，這對我來說是非常重要的轉變。

## 自我評量