---
title: weiso131 (許育瑋)
categories: Usesr
---
# 簡介
- 國立成功大學 資訊工程學系 116 級
- Github: [`weiso131`](https://github.com/weiso131)
- HackMD: [`weiso131`](https://hackmd.io/@weiso131)

# 2025 Linux 核心設計 春季班 自我評量
## 成果發表與貢獻
5 分。

- Concurrency Primer
  - 2025/6/11 [Note -latomic needed when using -mcx16](https://github.com/sysprog21/concurrency-primer/commit/f35f10856741fd0d3168a970cbee91542385145f)
  - 2025/6/11 [Fix function name in book: thread_pool_destroy](https://github.com/sysprog21/concurrency-primer/commit/1a4d1f78c69855cdb622edebe1f180f55069c918)
- 對課程使用的專案貢獻
  - ksort
    - 2025/3/23 [Fix uninitialized variable in error path](https://github.com/sysprog21/ksort/pull/6)
- 課程教材
  - 並行程式設計: Atomics 操作
     - 2025/5/8 `arm64` 得機器 → `arm64` 得機器
     - 2025/5/8 進進行 → 進行

## 作業/隨堂測驗
9 分。
- [2025q1 Homework1 (lab0)](https://hackmd.io/@weiso131/linux2025-homework1)
- [2025q1 Homework1 (ideas)](https://hackmd.io/@weiso131/linux2025-ideas)
- [2025q1 Homework2 (quiz1+2)](https://hackmd.io/@weiso131/linux2025-homework2)
- [2025q1 Homework3 (kxo)](https://hackmd.io/@weiso131/linux2025-homework3)
- [2025q1 Homework4 (quiz3+4)](https://hackmd.io/@weiso131/linux2025-homework4)
- [2025q1 Homework5 (assessment)](https://hackmd.io/@weiso131/linux2025-homework5)

### 作業重點回顧
- lab0
  - 理解 list_sort 程式實作
    - 利用 perf 比較與自身實作的效能差異
    - 理解 final_merge 會更快的原因為: 藉由減少節點存取來減少 cache miss
    - 有趣的收穫 : 在 list_sort.c 發現 likely 可以控制分支預測，在計算機組織學到 control hazard 後理解其意義
  - 參考 list_sort 最後再把鍊結串列恢復成雙向的方法，將原本的 q_merge 做改進，使其能夠支援任意長度佇列的合併
- hw2
  - [實作自己的 memory allocator](https://github.com/weiso131/Customize_allocator)
  - [理解整數開根號的實作原理](https://hackmd.io/p6i9MFQ3RiW3PxDsagfAWw#sqrti) 
- hw3 的 kxo 
  - 實現 ctrl + Q 顯示對亦歷史紀錄
    - 利用鍊結串列儲存對亦資料
    - 自訂 ioctl ，確保多個 terminal 都能正確的取得對亦紀錄

## 期末專題
9 分。
[Linux 核心專題: 改進 kxo](https://hackmd.io/XWDjMx0bTmmNIWvlNHsvKw?both)

### 專題實現項目
- 允許核心模組切換多種演算法，並整合 ttt 的 reinforcement_learning
  - 利用過去學過的 Q learning 演算法相關知識，更快的理解 TD learning 的實作，並將 reinforcement_learning 整合到此專案
- 縮減使用者和核心空間通訊的成本
  - 探討各種可能實作所需傳遞的 bytes 數量大小，並討論壓縮空間所需要的額外維護工作是否值得
- 改進棋盤展現的方式，並修訂核心通訊介面
  - 實現 write 支援使用者端棋盤控制
  - 實現 get_user_id 這個 ioctl 來在核心模組建立新的使用者並取得它在對應 tid 下的 user_id，此外，可藉由 bit_mask 指定使用的模式，實現使用者端切換 AI 演算法
- 支援多使用者並強化安全機制
  - 利用 current 這個 task_struct ，得知正在互動的執行緒的 id ，使其確保不同執行緒不會互相干擾
  - 了解 workqueue, kfifo, tasklet, wait_queue 的機制與使用要求，將這些知識應用於多使用者相關資料結構、流程的設計
- 理解何謂 lock-free
  - 釐清 lock-free 與 lock-less 的差異
  - 探討多使用者目前實作是否有可能在調整資料結構的使用後，達到 lock-free
- 在不犧牲棋力的前提，降低 CPU 使用率
  - 利用對 workqueue 的理解，使用 WQ_CPU_INTENSIVE 這個 flag ，確保 worker_pool 的其他工作不會被阻擋

### 觀摩其他同學的專題
- [Linux 核心專題: 輕量級容器實作和擴充](https://hackmd.io/elX0ZH57S6CQIEdmsfGPBQ?view)

## 與授課教師的互動

課堂問答:

## 所見所聞所感
## 自我評量